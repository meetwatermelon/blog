/*
Navicat MySQL Data Transfer

Source Server         : 李铁牛
Source Server Version : 50527
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50527
File Encoding         : 65001

Date: 2019-02-21 19:56:33
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `album`
-- ----------------------------
DROP TABLE IF EXISTS `album`;
CREATE TABLE `album` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `file_name` varchar(255) DEFAULT NULL,
  `flag` int(11) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL COMMENT '路径',
  `file` mediumint(9) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of album
-- ----------------------------
INSERT INTO `album` VALUES ('10', '大海.jpg', null, 'http://localhost:8080/6f3b855d-63d9-408d-b986-7386511e042b.jpg', null);
INSERT INTO `album` VALUES ('11', '可爱的小猫咪.jpg', null, 'http://localhost:8080/34546f08-db0d-4fe7-ac31-1756e3fbab0b.jpg', null);
INSERT INTO `album` VALUES ('19', '海底世界.jpg', null, 'http://localhost:8080/e0243ee2-742d-4a32-8d08-5010a9260b87.jpg', null);

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text,
  `date` datetime DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKy5kkohbk00g0w88fi05k2hcw` (`category_id`),
  CONSTRAINT `FKy5kkohbk00g0w88fi05k2hcw` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('18', '<h1>1.new、delete、malloc、free关系</h1><p style=\"text-align: justify;\">delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。malloc与free是C++/<a target=\"_blank\" href=\"http://lib.csdn.net/base/c\">C语言</a>的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。</p><h1>2.delete与 delete []区别</h1><p style=\"text-align: justify;\">delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective&nbsp; C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operatordelete来释放内存。”delete与New配套，delete []与new []配套</p><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\">MemTest*mTest1=newMemTest[10];&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;MemTest*mTest2=newMemTest;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>*pInt1=newint[10];&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>*pInt2=newint;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">delete</span>[]pInt1;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//-1-</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">delete</span>[]pInt2;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//-2-</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">delete</span>[]mTest1;<span style=\"color: rgb(0, 130, 0);\">//-3-</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">delete</span>[]mTest2;<span style=\"color: rgb(0, 130, 0);\">//-4-</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;在-4-处报错。&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\">这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针简单来说，用new分配的内存用delete删除用new[]分配的内存用delete[]删除delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p><h1>3.C和C++ 的共同点？不同之处？</h1><h1>4.继承的优缺点。</h1><p style=\"text-align: justify;\">类继承是在编译时刻静态定义的，且可直接使用，类继承可以较方便地改变父类的实现。但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响子类的行为。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p><p style=\"text-align: justify;\">（待补充）</p><p style=\"text-align: justify;\">&nbsp;</p><h1>5.C++有哪些性质（面向对象特点）</h1><p style=\"text-align: justify;\">封装，继承和多态。</p><p style=\"text-align: justify;\">在面向对象程序设计语言中，封装是利用可重用成分构造软件系统的特性，它不仅支持系统的可重用性，而且还有利于提高系统的可扩充性；消息传递可以实现发送一个通用的消息而调用不同的方法；封装是实现信息隐蔽的一种技术，其目的是使类的定义和实现分离。</p><h1>6.子类析构时要调用父类的析构函数吗？</h1><p style=\"text-align: justify;\">析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数<a target=\"_blank\" href=\"http://lib.csdn.net/base/javase\">Java</a>无析构函数深拷贝和浅拷贝</p><h1>7.多态，虚函数，纯虚函数</h1><p style=\"text-align: justify;\">多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在<u>运行和编译</u>两个方面：在程序运行时的多态性通过继承和虚函数来体现；</p><p style=\"text-align: justify;\">在程序编译时多态性体现在函数和运算符的重载上</p><p style=\"text-align: justify;\">&nbsp;</p><p style=\"text-align: justify;\">虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。</p><p style=\"text-align: justify;\">纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。</p><p style=\"text-align: justify;\">从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。</p><p style=\"text-align: justify;\">抽象类中不仅包括纯虚函数，也可包括虚函数。l抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。</p><h1>8.求下面函数的返回值（微软）</h1><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;func(x)&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">{&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;countx&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">while</span>(x)&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;countx&nbsp;++;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;x&amp;(x-1);&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">return</span>&nbsp;countx;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">}&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">假定x&nbsp;=&nbsp;9999。&nbsp;答案：8&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">思路：将x转化为2进制，看含有的1的个数。&nbsp;&nbsp;</span></li></ol><h1>9.什么是“引用”？申明和使用“引用”要注意哪些问题？</h1><p style=\"text-align: justify;\">答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p><h1>10.将“引用”作为函数参数有哪些特点？</h1><p style=\"text-align: justify;\">（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p><p style=\"text-align: justify;\">（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><p style=\"text-align: justify;\">（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用\"*指针变量名\"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p><h1>11.在什么时候需要使用“常引用”？　</h1><p style=\"text-align: justify;\">如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；</p><p style=\"text-align: justify;\">例1</p><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;a&nbsp;;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;&amp;ra=a;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">ra=1;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//错误</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">a=1;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//正确</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">例2&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">string&nbsp;foo(&nbsp;);&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">void</span>&nbsp;bar(string&nbsp;&amp;&nbsp;s);&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">那么下面的表达式将是非法的：&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">bar(foo(&nbsp;));&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">bar(<span style=\"color: blue;\">\"hello&nbsp;world\"</span>);&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\">原因在于foo( )和\"hello world\"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。</p><h1>12.将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</h1><p style=\"text-align: justify;\">格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 }</p><p style=\"text-align: justify;\">好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error! 注意事项：</p><p style=\"text-align: justify;\">（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了\"无所指\"的引用，程序会进入未知状态。</p><p style=\"text-align: justify;\">（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。</p><p style=\"text-align: justify;\">（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p><p style=\"text-align: justify;\">（4）流操作符重载返回值申明为“引用”的作用：</p><p style=\"text-align: justify;\">流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; \"hello\" &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p><p style=\"text-align: justify;\">例3</p><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\">＃i&nbsp;nclude&nbsp;&lt;iostream.h&gt;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;&amp;put(<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;n);&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;vals[10];&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;error=-1;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">void</span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">{&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">put(0)=10;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//以put(0)函数值作为左值，等价于vals[0]=10;&nbsp;</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">put(9)=20;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//以put(9)函数值作为左值，等价于vals[9]=20;&nbsp;</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">cout&lt;&lt;vals[0];&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">cout&lt;&lt;vals[9];&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">}&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;&amp;put(<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;n)&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">{&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">if</span>&nbsp;(n&gt;=0&nbsp;&amp;&amp;&nbsp;n&lt;=9&nbsp;)&nbsp;<span style=\"color: rgb(0, 102, 153);\">return</span>&nbsp;vals[n];&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">else</span>&nbsp;{&nbsp;cout&lt;&lt;<span style=\"color: blue;\">\"subscript&nbsp;error\"</span>;&nbsp;<span style=\"color: rgb(0, 102, 153);\">return</span>&nbsp;error;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">}&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\">（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p><h1>13.“引用”与多态的关系？</h1><p style=\"text-align: justify;\">引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。例4</p><p style=\"text-align: justify;\">Class A; Class B : Class A{...};&nbsp; B b; A&amp; ref = b;</p><h1>14.“引用”与指针的区别是什么？</h1><p style=\"text-align: justify;\">指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。</p><h1>15.什么时候需要“引用”？</h1><p style=\"text-align: justify;\">流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。以上 2-8 参考：<a href=\"http://develop.csai.cn/c/NO0000021.htm\" rel=\"nofollow\">http://develop.csai.cn/c/NO0000021.htm</a></p><h1>16.结构与联合有和区别？</h1><p style=\"text-align: justify;\"><br>(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。&nbsp;<br>&nbsp;(2). 对于联合的不同成员赋值, 将会对其它成员重写,&nbsp;原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</p><h1>17.面关于“联合”的题目的输出？</h1><p style=\"text-align: justify;\">a)</p><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\">＃i&nbsp;nclude&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">union</span>&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">{&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;i;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(46, 139, 87);\">char</span>&nbsp;x[2];&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">}a;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;</span></li><li><span style=\"color: black;\"><span style=\"color: rgb(0, 102, 153);\">void</span>&nbsp;main()&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">{&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">a.x[0]&nbsp;=&nbsp;10;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">a.x[1]&nbsp;=&nbsp;1;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">printf(<span style=\"color: blue;\">\"%d\"</span>,a.i);&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">}&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">答案：266&nbsp;(低位低地址，高位高地址，内存占用情况是Ox010A）&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\">b)</p><p><b>[cpp]</b>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/cyh183269855/article/details/53581574#\">copy</a></p><ol><li><span style=\"color: black;\">main()&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">union</span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">/*定义一个联合*/</span>&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;i;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">struct</span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">/*在联合中定义一个结构*/</span>&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>&nbsp;first;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>&nbsp;second;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}half;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}number;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number.i=0x4241;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">/*联合成员赋值*/</span>&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style=\"color: blue;\">\"%c%cn\"</span>,&nbsp;number.half.first,&nbsp;mumber.half.second);&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number.half.first=<span style=\"color: blue;\">\'a\'</span>;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">/*联合中结构成员赋值*/</span>&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number.half.second=<span style=\"color: blue;\">\'b\'</span>;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(<span style=\"color: blue;\">\"%xn\"</span>,&nbsp;number.i);&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getch();&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">答案：&nbsp;AB&nbsp;&nbsp;&nbsp;(0x41对应<span style=\"color: blue;\">\'A\'</span>,是低位；Ox42对应<span style=\"color: blue;\">\'B\'</span>,是高位）&nbsp;&nbsp;</span></li><li><span style=\"color: black;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6261&nbsp;(number.i和number.half共用一块地址空间）&nbsp;&nbsp;</span></li></ol><h1>18.关联、聚合(Aggregation)以及组合(Composition)的区别？</h1><p style=\"text-align: justify;\">涉及到UML中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就是一种关联关系；聚合表示has-a的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：从实现的角度讲，聚合可以表示为:</p><p style=\"text-align: justify;\">class A {...}&nbsp; class B { A* a; .....}</p><p style=\"text-align: justify;\">而组合表示contains-a的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：实现的形式是:</p><p style=\"text-align: justify;\">class A{...} class B{ A a; ...}</p><h1>19.面向对象的三个基本特征，并简单叙述之？</h1><p style=\"text-align: justify;\">1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected,public)</p><p style=\"text-align: justify;\">2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。</p><p style=\"text-align: justify;\">3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p><h1>20.重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？</h1><p style=\"text-align: justify;\">常考的题目。从定义上来说：</p><p style=\"text-align: justify;\">重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p><p style=\"text-align: justify;\">重写：是指子类重新定义父类虚函数的方法。</p><p style=\"text-align: justify;\">从实现原理上来说：</p><p style=\"text-align: justify;\">重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！</p><p style=\"text-align: justify;\">重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。</p>', '2018-06-19 17:16:19', 'C语言小知识点练习总结', '2');
INSERT INTO `article` VALUES ('19', '<p style=\"text-align: justify;\">有云天下，有人江湖，编程的江湖亦是如此。编程的江湖上也是豪强诸起，门派众多，各足鼎立。虽说没有什么武林大会，也没有华山论剑，但是编程的江湖，也不比他们差，亦是精彩纷呈。</p><p style=\"text-align: justify;\">在比较的老派和老牌的门派当中，C 门派最为受人尊敬，辈分较高，C++ 门派都属于 C 门派之列，后来由于其独有的气势和特点， C 门派中的 C 和 C++ ，都有一种华山门派剑宗和气宗的意思，但是毕竟同气连枝，在面对共同敌人的时候，还是师兄弟的关系。</p><p style=\"text-align: justify;\">而 Java 门派其弟子更是众多，自诞生之初，尤其善于后端技术，以其精湛稳定的技术持续火爆了近20年，在江湖上也有不减之势。</p><p style=\"text-align: justify;\">在武林排行前十的门派中， PHP 也是一个强势的存在，对它的赞美和推崇亦是赞不绝口，江湖中毕竟传言：它才是世界上最好的门派。要论天下武功，唯有 PHP 。作为后起之秀，吸收了Java 和 C 以及 Perl 等技术特点，很快蚕食了和席卷了 Web 端，让 Java 在 Web 端损失惨重。</p><p style=\"text-align: justify;\">在此期间，Python ，Ruby ，JavaScript 等门派都在涌动的暗流中暗自发力，期待能有一天，与武林中扬名立万，一统江湖。</p><p style=\"text-align: justify;\">这都是在互联网时代上叱咤风云的门派了，C 门派在其速度上是其他门派所不及的，可谓稳准狠，软硬通吃，而其他门派都是吃软不吃硬，随着时代的发展，到了移动互联网时代，Java 竟然在 Android 地界上开辟了一个新天地。</p><p style=\"text-align: justify;\">随着历史进程的演进，谁先站住终端平台，谁就有先发制人的优势，不知不觉就在被人追赶超越的时候，Java 在 Android 的地界上火了，已然成为了燎原之势。一时间让其他门派望其项背，长期占据琅琊榜武林门派排行的第一名，其气势犹如武林盟主一般。殊不知，在更换了掌门以后得 Java，作为掌门人的 Oracle 喜欢使用阴招，到处往其他门派中送出间谍和卧底，让其他门派有点措手不及，使用武林名声要挟其他门派，说其他门派盗其武林绝学，索要各种损失费。</p><p style=\"text-align: justify;\">在半梦半醒中，在洋洋得意时，JavaScript 忽然来到了Java 门派这里，送上了拜贴，求见 Java 。</p><p style=\"text-align: justify;\">JavaScript 行色匆匆，慌慌张张的见到Java：“Java 师兄，小弟来找你有急事求见。”</p><p style=\"text-align: justify;\">“你 TMD 的跟谁攀关系呢？谁是你师兄，你从哪里论的？我跟你没毛关系。什么事？有话快说，有屁快放。”Java 一脸孤傲且有点生气的说。</p><p style=\"text-align: justify;\">JavaScript 心里暗想：“好吧，我不跟你计较，自己倒霉了，还不知道，傲娇个屁啊！”</p><p style=\"text-align: justify;\">“你知道吗？据从谷歌那里传出来的消息说，在功力较高的弟子中有 35% 的人在Android 地界都投入到了 Kotlin 门派，而且这个数字正在逐月递增，越来越多的兄弟要加入了。你损失惨重啊！”JavaScript 暗自庆幸且看笑话的说。</p><p style=\"text-align: justify;\">Java：“我知道了，我门派弟子都投向其他门派还不知道吗？用你来说，这也不能怪我啊，自从换了掌门，在于谷歌打口水仗以来，看似胜了，其实又败了，我也无能为力。你小子也不是什么好东西，你来看我笑话的吧？”</p><p style=\"text-align: justify;\">JavaScript：“不如咱们开个武林大会吧，召集众门派，划清地盘，分清界限，最好井水不犯河水。”</p><p style=\"text-align: justify;\">Java心里暗想：“划清地盘，分清界限？就尼玛 JavaScript 划不清楚界限，分不清楚地盘，自移动互联网时代以来，你野心勃勃，到处抢生意。肚子里肯定没什么好事，一肚子坏水，我要看看你到底想干嘛？”</p><p style=\"text-align: justify;\">“好，那咱就召开，由 C 门派主持会议，由我光发英雄贴，你负责整个大会的安排，具体你操作。”Java试探性的说。</p><p style=\"text-align: justify;\">JavaScript：“好，马上干。一溜烟高高兴兴的马上去行动了。”</p><p style=\"text-align: justify;\">武林大会在 JavaScript 的安排下，如期举行，看在 C 和 Java 的面上确实来了不少门派。C 老祖出来主持会议，说：“今天召集大家来，是为了我们江湖和谐稳定，不要再各自为战，造成内耗。”</p><p style=\"text-align: justify;\">JavaScript 说：“C 老哥说的对啊，我们要团结，要合作，不要互相抢占地盘。我们 JavaScript 门派一向都是主张合作，在各领域合作，互利共赢。不管是前端，还是后台，各项方面，只要需要，我们都可以合作，因为哥们活全。”</p><p style=\"text-align: justify;\">“卧槽，原来召开大会的目的是这样啊！JavaScript 想暗度陈仓，通力合作，一统江湖啊！”Java内心想。</p><p style=\"text-align: justify;\">Python：“通力合作？你们 JavaScript 确实活全。但是不精通，想合作行，先把你师弟 Node.js 从后端撤出再说。现在是什么时代？人工智能时代，哥们怕你们？”</p><p style=\"text-align: justify;\">\"PHP，你有什么要说的？\"C 老祖问。</p><p style=\"text-align: justify;\">\"我没什么要说的，我们很专注，我们有自己的能力和业务，作为江湖上传闻最好的门派，我们一向低调。我们都行。\"PHP 说。</p><p style=\"text-align: justify;\">OC 说：“我想静静，swift 一出，我家里都快揭不开锅了，不是亲生的毕竟不行啊！”</p><p style=\"text-align: justify;\">Java 这时频频点头。</p><p style=\"text-align: justify;\">kotlin：“对啊，我虽然不是亲生，胜似亲生，但是毕竟官方首席推荐了，我还是比较幸运的，对吧，Java 老哥？”</p><p style=\"text-align: justify;\">Java：“你牛逼，你厉害行了吧？没有我和 JavaScript 的支持，你屁也不是。在我们的环境下生存，还抢我们的饭碗。”</p><p style=\"text-align: justify;\">JavaScript：“大家不要吵嘛，咱们目的是合作，只要能做生意，挣钱，都好说。咱们要不选个盟主？用于调节纠纷和合作。”我感觉选择个活全的当盟主，有利于领导，毕竟都知道各处的困难嘛！</p><p style=\"text-align: justify;\">PHP：“论辈分，论资历，论能力，论功力，当然……当然不是我，我推荐 C 老哥。”</p><p style=\"text-align: justify;\">C老祖：“不敢当，不敢当。其实内心想，这破盟主有啥好当的，乱炖。”</p><p style=\"text-align: justify;\">Java：“要论最近20年的流行度和统治力的话，我应该当仁不让。”</p><p style=\"text-align: justify;\">Python：“且，你没看最近的琅琊榜武林排行吗？把榜单拿来瞧一瞧，谁是第一？在人工智能时代，流行度，我第一，排行榜，我第一。你没落了，心里没点逼数吗？”</p><p style=\"text-align: justify;\">Go：“go,go,go，我走了，太吵人了。”Go 暗想：“这这些年都说要推翻java的统治地位，也没见他被推翻，作为后起之秀的我，不想这些，只想努力做好自己。”在大会上一言没发的go走了。</p><p style=\"text-align: justify;\">其他门派各自不服，吵声越来越大，而 JavaScript 在暗喜，我的目的达到了，吵个你死我活，我渔翁得利，等你们两败俱伤，我好一统江湖。</p><p style=\"text-align: justify;\">总结，以上内容纯属虚构，如有雷同，没错是我写的。关于Java 危矣的言论，我们就让Java自己现身说法。</p><p style=\"text-align: justify;\">Java ：好了，就让他们吵吧，我来说说我自己的观点，不可否认kotlin在蚕食我在安卓端的市场，它有它的优势，我也有我的特点，而且kotlin现在总体来说确实不错，但是不能跟我20多年的稳定和积累所比。而关于大数据，人工智能方面，Python 确实增长很快，但是等你真懂了大数据和人工智能，你都不会去想你用的是 Python 还是 Java 了，在纠结语言的时候，说明你还处在初级阶段。另外，我在自诞生以来，就没错过互联网上的任何一个热点，所以才会这么持久。JavaScript 不就是因为我 Java 太火太流行，为了蹭我的热点才起这跟我有关系的名字吗？其实一点关系没有。当程序员语言只是工具，不要太在乎用什么工具，应该在乎如何用好工具，如何使用工具。</p>', '2018-06-20 22:34:35', 'Java 危矣！统治地位已不复存在？', '1');
INSERT INTO `article` VALUES ('20', '<p style=\"text-align: justify;\">课程主要分享给初学者学习自动化少走弯路，从自己的工作经验分享给刚学习自动化测试不久的学者，提高初学者的工作效率，不再苦于开发自动化测试框架而无从下手。</p><p style=\"text-align: justify;\">本场 Chat 主要内容有：</p><ol><li>学开发框架之前，先把 Python 的基础打好；</li><li>开发自己的框架之前，先学习别人的框架；</li><li>基于开源框架，开发属于自己的测试框架；</li><li>在自己的框架中，加以优化创新。</li></ol><p style=\"text-align: justify;\">在本次 Chat 中，重点会侧重于与大家交流如何提高自己的能力去搭建一个自动化测试框架，需要怎样的能力才可以去开发框架，在开发框架中我们需要做哪些。通过这次交流，你会比现在更有效率，更有思路去做自动化测试以及开发出属于自己的优秀自动化测试框架。</p>', '2018-06-20 22:36:13', '用拆墙的方式学习 Python 自动化测试', '6');
INSERT INTO `article` VALUES ('29', '<p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">过滤器和拦截器的区别：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　①拦截器是基于<a href=\"http://lib.csdn.net/base/javaee\" target=\"_blank\">Java</a>的反射机制的，而过滤器是基于函数回调。<br>　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。<br>　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。<br>　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。<br>　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　写了点测试代码，顺便整理一下思路，搞清楚这几者之间的顺序：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　1.过滤器是JavaEE标准，采用函数回调的方式进行。是在请求进入容器之后，还未进入Servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。</span></p><p><br>&nbsp;</p><pre><code>    @Override\r\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\r\n        System.out.println(\"before...\");\r\n        chain.doFilter(request, response);\r\n        System.out.println(\"after...\");\r\n    }</code></pre><p><br>&nbsp;</p><p style=\"text-align: justify;\">　<span style=\"font-size: 18px;\">　chain.doFilter(request, response);这个方法的调用作为分水岭。事实上调用Servlet的doService()方法是在chain.doFilter(request, response);这个方法中进行的。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　2.拦截器是被包裹在过滤器之中的。</span></p><p><br>&nbsp;</p><pre><code>    @Override\r\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\r\n        System.out.println(\"preHandle\");\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\r\n        System.out.println(\"postHandle\");\r\n    }\r\n\r\n    @Override\r\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\r\n        System.out.println(\"afterCompletion\");\r\n    }</code></pre><p><br>&nbsp;</p><p style=\"text-align: justify;\">　　<span style=\"font-size: 18px;\">a.preHandle()这个方法是在过滤器的chain.doFilter(request, response)方法的前一步执行，也就是在 [System.out.println(\"before...\")][chain.doFilter(request, response)]之间执行。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　b.preHandle()方法之后，在return&nbsp;ModelAndView之前进行，可以操控Controller的ModelAndView内容。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　c.afterCompletion()方法是在过滤器返回给前端前一步执行，也就是在[chain.doFilter(request, response)][System.out.println(\"after...\")]之间执行。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　3.SpringMVC的机制是由同一个Servlet来分发请求给不同的Controller，其实这一步是在Servlet的service()方法中执行的。所以过滤器、拦截器、service()方法，dispatc()方法的执行顺序应该是这样的，大致画了个图：其实非常好测试，自己写一个过滤器，一个拦截器，然后在这些方法中都加个断点，一路F8下去就得出了结论.</span></p><p>&nbsp;</p><p style=\"text-align: justify;\">　　<span style=\"font-size: 18px;\">总结：拦截器功在对请求权限鉴定方面确实很有用处，在我所参与的这个项目之中，第三方的远程调用每个请求都需要参与鉴定，所以这样做非常方便，而且他是很独立的逻辑，这样做让业务逻辑代码很干净。和框架的其他功能一样，原理很简单，使用起来也很简单，大致看了下SpringMVC这一部分的源码，其实还是比较容易理解的。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 18px;\">　　我们项目中仅仅用到了preHandle这个方法，而未用其他的，框架提供了一个已经实现了拦截器接口的适配器类HandlerInterceptorAdapter，继承这个类然后重写一下需要用到的方法就行了，可以少几行代码，这种方式Java中很多地方都有体现。</span></p><h1><br></h1>', '2018-06-20 22:37:33', 'Struts2中过滤器和拦截器的区别', '1');
INSERT INTO `article` VALUES ('30', '<p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">C++中一般创建对象，拷贝或赋值的方式有构造函数，拷贝构造函数，赋值函数这三种方法。下面就详细比较下三者之间的区别以及它们的具体实现</span><br></p><h1>1.构造函数</h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">构造函数是一种特殊的类成员函数，是<span style=\"color: rgb(255, 0, 0);\">当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存</span>。（构造函数的命名必须和类名完全相同）</span><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">首先说一下一个C++的空类，编译器会加入哪些默认的成员函数</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">·默认构造函数和拷贝构造函数</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">·析构函数</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">·赋值函数（赋值运算符）</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">·取值函数</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">**即使程序没定义任何成员，编译器也会插入以上的函数！&nbsp;<br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">注意：<span style=\"color: rgb(255, 0, 0);\">构造函数可以被重载，可以多个，可以带参数；</span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">析构函数只有一个，不能被重载，不带参数</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">而默认构造函数没有参数，它什么也不做。当没有重载无参构造函数时，</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp; A a就是通过默认构造函数来创建一个对象</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">下面代码为构造函数重载的实现</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">&lt;span&nbsp;style=<span style=\"color: rgb(0, 0, 255);\">\"font-size:14px;\"</span>&gt;<span style=\"color: rgb(0, 102, 153);\">class</span>&nbsp;A&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;m_i;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">Public:&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;A()&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;Cout&lt;&lt;”无参构造函数”&lt;&lt;endl;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">}&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A(<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;i):m_i(i)&nbsp;{}&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//初始化列表</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">}&lt;/span&gt;&nbsp;&nbsp;</span></li></ol><h1><span style=\"font-size: 24px;\">2.拷贝构造函数</span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">拷贝构造函数是C++独有的，它是<span style=\"color: rgb(255, 0, 0);\">一种特殊的构造函数，用基于同一类的一个对象构造和初始化另一个对象。</span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">当没有重载拷贝构造函数时，通过默认拷贝构造函数来创建一个对象</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A a;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A b(a);</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A b=a; &nbsp;都是拷贝构造函数来创建对象b</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">先说下什么时候拷贝构造函数会被调用：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">在C++中，3种对象需要复制，此时拷贝构造函数会被调用</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">1）一个对象以值传递的方式传入函数体</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">2）一个对象以值传递的方式从函数返回</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">3）一个对象需要通过另一个对象进行初始化</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">什么时候编译器会生成默认的拷贝构造函数：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷贝构造函数，编译器就不在生成。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">因为系统提供的默认拷贝构造函数工作方式是内存拷贝，也就是浅拷贝。如果对象中用到了需要手动释放的对象，则会出现问题，这时就要手动重载拷贝构造函数，实现深拷贝。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">下面说说深拷贝与浅拷贝：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在）</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">拷贝构造函数重载声明如下：&nbsp;<br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A (const A&amp;other)</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">下面为拷贝构造函数的实现：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">&lt;span&nbsp;style=<span style=\"color: rgb(0, 0, 255);\">\"font-size:14px;\"</span>&gt;<span style=\"color: rgb(0, 102, 153);\">class</span>&nbsp;A&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;<span style=\"color: rgb(46, 139, 87);\">int</span>&nbsp;m_i&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;A(<span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;A&amp;&nbsp;other):m_i(other.m_i)&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;Cout&lt;&lt;”拷贝构造函数”&lt;&lt;endl;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">}&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">}&lt;/span&gt;&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px;\"><br></span></p><h1><span style=\"font-size: 24px;\">3.赋值函数</span></h1><p style=\"text-align: justify;\"><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A a;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">A b;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">b=a;&nbsp;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">赋值运算的重载声明如下：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;A&amp; operator = (const A&amp; other)</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">通常大家会对拷贝构造函数和赋值函数混淆，这儿仔细比较两者的区别：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">1）<span style=\"color: rgb(255, 0, 0);\">拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。</span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">&lt;span&nbsp;style=<span style=\"color: rgb(0, 0, 255);\">\"font-size:14px;\"</span>&gt;<span style=\"color: rgb(0, 102, 153);\">class</span>&nbsp;&nbsp;A;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;a;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;b=a;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//调用拷贝构造函数（b不存在）</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;c(a)&nbsp;;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//调用拷贝构造函数</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 130, 0);\">/****/</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\"><span style=\"color: rgb(0, 102, 153);\">class</span>&nbsp;&nbsp;A;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;a;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">b&nbsp;=&nbsp;a&nbsp;;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//调用赋值函数(b存在)&lt;/span&gt;</span>&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。（这些要点会在下面的String实现代码中体现）</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">！！！如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是<span style=\"color: rgb(255, 0, 0);\">将拷贝构造函数和赋值函数声明为私有函数</span>，不用编写代码。如：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">&lt;span&nbsp;style=<span style=\"color: rgb(0, 0, 255);\">\"font-size:14px;\"</span>&gt;<span style=\"color: rgb(0, 102, 153);\">class</span>&nbsp;A&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;<span style=\"color: rgb(0, 102, 153);\">private</span>:&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;A(<span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;A&amp;&nbsp;a);&nbsp;<span style=\"color: rgb(0, 130, 0);\">//私有拷贝构造函数</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;A&amp;&nbsp;operate=(<span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;A&amp;&nbsp;a);&nbsp;<span style=\"color: rgb(0, 130, 0);\">//私有赋值函数</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">}&lt;/span&gt;&nbsp;&nbsp;</span></li></ol><p><span style=\"font-size: 14px;\">如果程序这样写就会出错：</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">&lt;span&nbsp;style=<span style=\"color: rgb(0, 0, 255);\">\"font-size:14px;\"</span>&gt;A&nbsp;a;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;b(a);&nbsp;<span style=\"color: rgb(0, 130, 0);\">//调用了私有拷贝构造函数，编译出错</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">A&nbsp;b;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">b=a;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//调用了私有赋值函数，编译出错&lt;/span&gt;</span>&nbsp;&nbsp;</span></li></ol><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">所以如果类定义中有指针或引用变量或对象，为了避免潜在错误，最好重载拷贝构造函数和赋值函数。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"><br></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">下面以string类的实现为例，完整的写了普通构造函数，拷贝构造函数，赋值函数的实现。</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\"></span></p><p>[cpp]&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">view plain</a>&nbsp;<a href=\"https://blog.csdn.net/zcyzsy/article/details/52132936#\" target=\"_blank\">copy</a></p><ol><li><span style=\"color: rgb(0, 0, 0);\">String::String(<span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>*&nbsp;str)&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//普通构造函数</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;construct&lt;&lt;endl;&nbsp;&nbsp;</li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;</span>if<span style=\"color: rgb(0, 0, 0);\">(str==NULL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"color: rgb(0, 130, 0);\">//如果str&nbsp;为NULL，就存一个空字符串“”</span><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;</span>{&nbsp;&nbsp;</li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_string=<span style=\"color: rgb(0, 102, 153);\">new</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>[1];&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*m_string&nbsp;=<span style=\"color: rgb(0, 0, 255);\">\'\\0\'</span>;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;else<span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_string=&nbsp;<span style=\"color: rgb(0, 102, 153);\">new</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>[strlen(str)+1]&nbsp;;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//分配空间</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(m_string,str);&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>}&nbsp;&nbsp;</li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;</span>}&nbsp;&nbsp;</li><li><br></li><li>String::String(<span style=\"color: rgb(0, 102, 153);\">const</span><span style=\"color: rgb(0, 0, 0);\">&nbsp;String&amp;other)&nbsp;&nbsp;&nbsp;</span><span style=\"color: rgb(0, 130, 0);\">//拷贝构造函数</span><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span style=\"color: rgb(0, 0, 255);\">\"copy&nbsp;construct\"</span>&lt;&lt;endl;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;m_string=<span style=\"color: rgb(0, 102, 153);\">new</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>[strlen(other.m_string)+1];&nbsp;<span style=\"color: rgb(0, 130, 0);\">//分配空间并拷贝</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;strcpy(m_string,other.m_string);&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span></li><li>}&nbsp;&nbsp;</li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">String&nbsp;&amp;&nbsp;String::operator=(<span style=\"color: rgb(0, 102, 153);\">const</span>&nbsp;String&amp;&nbsp;other)&nbsp;<span style=\"color: rgb(0, 130, 0);\">//赋值运算符</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;<span style=\"color: rgb(0, 0, 255);\">\"operator&nbsp;=funtion\"</span>&lt;&lt;endl&nbsp;;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">if</span>(<span style=\"color: rgb(0, 102, 153);\">this</span>==&amp;other)&nbsp;<span style=\"color: rgb(0, 130, 0);\">//如果对象和other是用一个对象，直接返回本身</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">return</span>&nbsp;*<span style=\"color: rgb(0, 102, 153);\">this</span>;&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">delete</span>&nbsp;[]m_string;&nbsp;<span style=\"color: rgb(0, 130, 0);\">//先释放原来的内存</span>&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_string=&nbsp;<span style=\"color: rgb(0, 102, 153);\">new</span>&nbsp;<span style=\"color: rgb(46, 139, 87);\">char</span>[strlen(other.m_string)+1];&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(m_string,other.m_string);&nbsp;&nbsp;</span></li><li><span style=\"color: rgb(0, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(0, 102, 153);\">return</span>&nbsp;*&nbsp;<span style=\"color: rgb(0, 102, 153);\">this</span>;&nbsp;&nbsp;</span></li><li>}</li></ol><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">一句话记住三者：对象不存在，且没用别的对象来初始化，就是调用了构造函数；</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对象不存在，且用别的对象来初始化，就是拷贝构造函数（上面说了三种用它的情况！）</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对象存在，用别的对象来给它赋值，就是赋值函数。</span></p>', '2018-06-20 22:39:13', ' C++中构造函数，拷贝构造函数和赋值函数的区别和实现', '2');
INSERT INTO `article` VALUES ('31', '<p style=\"text-align: justify;\">当我们编写Python代码时，我们得到的是一个包含Python代码的以<code>.py</code>为扩展名的文本文件。要运行代码，就需要Python解释器去执行<code>.py</code>文件。</p><p style=\"text-align: justify;\">由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p><h3>CPython</h3><p style=\"text-align: justify;\">当我们从<a href=\"https://www.python.org/\" target=\"_blank\">Python官方网站</a>下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行<code>python</code>就是启动CPython解释器。</p><p style=\"text-align: justify;\">CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p><h3>IPython</h3><p style=\"text-align: justify;\">IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。</p><p style=\"text-align: justify;\">CPython用<code>&gt;&gt;&gt;</code>作为提示符，而IPython用<code>In [序号]:</code>作为提示符。</p><h3>PyPy</h3><p style=\"text-align: justify;\">PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用<a href=\"http://en.wikipedia.org/wiki/Just-in-time_compilation\" target=\"_blank\">JIT技术</a>，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。</p><p style=\"text-align: justify;\">绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解<a href=\"http://pypy.readthedocs.org/en/latest/cpython_differences.html\" target=\"_blank\">PyPy和CPython的不同点</a>。</p><h3>Jython</h3><p style=\"text-align: justify;\">Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p><h3>IronPython</h3><p style=\"text-align: justify;\">IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p><h3>小结</h3><p style=\"text-align: justify;\">Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><p style=\"text-align: justify;\">本教程的所有代码只确保在CPython 3.x版本下运行。请务必在本地安装CPython（也就是从Python官方网站下载的安装程序）</p>', '2018-06-20 22:42:13', 'Python解释器', '5');
INSERT INTO `article` VALUES ('32', '<p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\">变量</span><br></p><p style=\"text-align: justify;\">&nbsp; $a = 1</p><p style=\"text-align: justify;\">&nbsp; echo memory_get_usage(), \'&lt;br /&gt;\';&nbsp;&nbsp; //&nbsp;&nbsp;119632<br></p><p style=\"text-align: justify;\">&nbsp; $b = $a</p><p style=\"text-align: justify;\">&nbsp; echo memory_get_usage(), \'&lt;br /&gt;\';&nbsp;&nbsp; //&nbsp;&nbsp;119680</p><p style=\"text-align: justify;\">&nbsp; $a = 1;</p><p style=\"text-align: justify;\">&nbsp;&nbsp; echo memory_get_usage(), \'&lt;br /&gt;\';&nbsp;&nbsp; //&nbsp;&nbsp;119712<br></p><p style=\"text-align: justify;\">$a和 $b都指向$a的内存地址，并不会copy一块内存地址出来，因为COW（copy on writer），只有再对$a进行赋值的时候$b才能新创建一块内存地址，所以内存增加。</p><p style=\"text-align: justify;\">&nbsp;&nbsp; $b = &amp;$a&nbsp;&nbsp;<br></p><p style=\"text-align: justify;\">&nbsp; echo memory_get_usage(), \'&lt;br /&gt;\';&nbsp;&nbsp; //&nbsp;&nbsp;119712<br></p><p style=\"text-align: justify;\">$a和$b指向一个内存地址，再对$a进行修改也不会创建新的内存地址，<span style=\"color: rgb(255, 0, 0);\">如果unset($b)那么之后消除$b对$a的引用，并不会把$a指向的内存地址给消除了</span>。</p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\">对象</span></p><p style=\"text-align: justify;\">class Person{</p><p style=\"text-align: justify;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public $Name = “张三”；<br></p><p style=\"text-align: justify;\">}</p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp; $d = new Person();</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp; &nbsp;$e = $d;</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp; $d-&gt;name = \"zhamgsan\";</span></p><p><span style=\"font-size: 14px;\">?&gt;</span></p><p style=\"text-align: justify;\">此时$b和$a都同时指向一个内存地址，对$a 进行修改$a-&gt;Name = \"李四\"后&nbsp; $a$b还是指向一块地址。</p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\">练习</span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><span style=\"font-size: 14px;\">$data = [a,b,c]</span></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><span style=\"font-size: 14px;\">foreach($data as $k=&gt;$v){</span></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $v = &amp;$data[$k]<br></span></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><span style=\"font-size: 14px;\">}</span></span></span></p><p style=\"text-align: justify;\"><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><span style=\"color: rgb(0, 0, 0);\"><span style=\"font-size: 14px;\">程序运行一遍后 $data打印出来是多少？</span></span><br></span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\">第一次循环 $k = 0&nbsp; $v =&nbsp; a 循环体内&nbsp; $v = &amp;$data[0] = a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==&gt;&nbsp; a,b,c<br></p><p style=\"text-align: justify;\">第二次循环 $k = 1 $v&nbsp; = b 因为$v变化,$v = &amp;$data[0], 所以$data[0] = b ，循环体内 $v = &amp;$data[1] = b&nbsp;&nbsp;&nbsp;&nbsp; ===&gt; b,b,c<br></p><p style=\"text-align: justify;\">第三次循环&nbsp; $k= 2 $v&nbsp; = c 同上$v变化 ,$v = &amp;$data[1],所以$data[1] = c，循环体内$v= &amp;$data[2] = c===&gt;b,c,c</p>', '2018-06-20 22:43:53', 'PHP---引用', '3');
INSERT INTO `article` VALUES ('33', '<h3>1、HTML简介</h3><p style=\"text-align: justify;\">HTML指的是超文本标记语言（Hyper Text Markip Language），它不是一种编程语言而是一种标记语言，通过使用标签来描述网页。</p><h3>2、HTML结构</h3><p style=\"text-align: justify;\">HTML文件以<code>.html</code>结尾，里面包含两部分，首先是一个<code>&lt;!DOCTYPE html&gt;</code>标签，用于文档声明，标识文档的版本，来使浏览器正确识别；然后是一个<code>&lt;html&gt;</code>标签，这里面包含的就是网页部分。</p><p style=\"text-align: justify;\"><code>&lt;html&gt;</code><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">标签中也有两部分，包括</span><code>&lt;head&gt;</code><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">标签和</span><code>&lt;body&gt;</code><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">标签，</span><code>&lt;body&gt;</code><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">标签用来描述网页中存在的内容，</span><code>&lt;head&gt;</code><span style=\"color: rgb(79, 79, 79); font-size: 16px;\">标签用来控制这些内容怎么显示。</span><br></p><h3>3、<code>&lt;head&gt;</code></h3><p style=\"text-align: justify;\"><code>&lt;head&gt;</code>标签是所有头部元素的容器，可包含网页的样式，脚本，提供元信息等等，以下标签可以添加到<code>&lt;head&gt;</code>标签中：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;script&gt;</code>&nbsp;。</p><h4>1）<code>&lt;title&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;title&gt;</code>标签定义网页的标题，显示在浏览器标签页上，提供页面被添加到收藏夹时显示的标题，显示在搜索引擎结果中的页面标题。</p><h4>2）<code>&lt;base&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;base&gt;</code>标签为页面上所有的链接规定默认地址或默认目标。</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">base</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">href</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"http://localhost:8080/study\"</span>/&gt;</span><ul class=\"pre-numbering\" style=\"outline: 0px; padding: 8px 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; list-style: none; word-break: break-all; position: absolute; width: 48px; background-color: rgb(238, 240, 244); top: 0px; left: 0px; text-align: right;\"><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">1</li></ul></code></pre><h4>3）<code>&lt;link&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;link&gt;</code>标签定义文档与外部资源之间的关系，最常用于连接样式表。</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">link</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">rel</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"stylesheet\"</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">type</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"text/css\"</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">href</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"mystyle.css\"</span>/&gt;</span><ul class=\"pre-numbering\" style=\"outline: 0px; padding: 8px 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; list-style: none; word-break: break-all; position: absolute; width: 48px; background-color: rgb(238, 240, 244); top: 0px; left: 0px; text-align: right;\"><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">1</li></ul></code></pre><h4>4）<code>&lt;meta&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;meta&gt;</code>标签提供关于HTML文档的元数据，不会显示在页面上，但是浏览器是可读的，一般用于规定页面的描述、关键词、文档的作者、最后修改时间以及其它元数据。</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">meta</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">name</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"personal web\"</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">content</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"This is a personal web!\"</span>/&gt;</span></code></pre><p style=\"text-align: justify;\"><span style=\"color: rgb(79, 79, 79); font-size: 16px;\"><br></span></p><h4>5）<code>&lt;style&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;style&gt;</code>标签用于定义HTML文档的样式信息，我们可以在该标签内定义我们所需要的样式。</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">style</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">type</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"text/css\"</span>&gt;</span><span class=\"css\" style=\"outline: 0px; word-break: break-all;\">\r\n<span class=\"hljs-tag\" style=\"outline: 0px; word-break: break-all;\">p</span><span class=\"hljs-rules\" style=\"outline: 0px; word-break: break-all;\">{\r\n    <span class=\"hljs-rule\" style=\"outline: 0px; word-break: break-all;\"><span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all;\">color</span>:<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">red</span></span>;\r\n<span class=\"hljs-rule\" style=\"outline: 0px; word-break: break-all;\">}</span></span>\r\n</span><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;/<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">style</span>&gt;</span><ul class=\"pre-numbering\" style=\"outline: 0px; padding: 8px 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; list-style: none; word-break: break-all; position: absolute; width: 48px; background-color: rgb(238, 240, 244); top: 0px; left: 0px; text-align: right;\"><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">1</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">2</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">3</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">4</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">5</li></ul></code></pre><h4>6）<code>&lt;script&gt;</code></h4><p style=\"text-align: justify;\"><code>&lt;script&gt;</code>标签用于定义和引用客户端脚本，比如javascript。</p><p style=\"text-align: justify;\">定义脚本：</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">script</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">type</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"text/javascript\"</span>&gt;</span><span class=\"javascript\" style=\"outline: 0px; word-break: break-all;\">\r\n\r\n</span><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;/<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">script</span>&gt;</span><ul class=\"pre-numbering\" style=\"outline: 0px; padding: 8px 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; list-style: none; word-break: break-all; position: absolute; width: 48px; background-color: rgb(238, 240, 244); top: 0px; left: 0px; text-align: right;\"><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">1</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">2</li><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">3</li></ul></code></pre><p style=\"text-align: justify;\">引用脚本文件：</p><pre><code><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">script</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">type</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"text/javascript\"</span> <span class=\"hljs-attribute\" style=\"outline: 0px; word-break: break-all; color: rgb(79, 79, 79);\">src</span>=<span class=\"hljs-value\" style=\"outline: 0px; word-break: break-all; color: rgb(0, 153, 0);\">\"myjavascript.js\"</span>&gt;</span><span class=\"hljs-tag\" style=\"outline: 0px; color: rgb(0, 102, 102); word-break: break-all;\">&lt;/<span class=\"hljs-title\" style=\"outline: 0px; color: rgb(79, 79, 79); word-break: break-all;\">script</span>&gt;</span><ul class=\"pre-numbering\" style=\"outline: 0px; padding: 8px 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; list-style: none; word-break: break-all; position: absolute; width: 48px; background-color: rgb(238, 240, 244); top: 0px; left: 0px; text-align: right;\"><li style=\"outline: 0px; padding: 0px 8px; margin: 0px; list-style: none; word-break: break-all; color: rgb(153, 153, 153);\">1</li></ul></code></pre><h3>4、<code>&lt;body&gt;</code></h3><p style=\"text-align: justify;\"><code>&lt;body&gt;</code>标签用于放置其它元素，呈现可见的页面内容。</p><p style=\"text-align: justify;\"><br></p><h3><br></h3>', '2018-06-20 22:47:50', 'HTML', '4');
INSERT INTO `article` VALUES ('34', '<p><span style=\"font-size: 14px; color: rgb(0, 0, 0);\">通过前面一系列的学习了解了PHP的常量和变量，那么你们知道PHP常量与变量有什么关系和区别吗？别急，下面就带着大家看看php常量与变量的关系和区别</span></p><p style=\"text-align: justify;\">再来了解一下<span style=\"color: rgb(51, 51, 51);\">什么是变量和常量</span></p><p style=\"text-align: justify;\"></p><p style=\"text-align: justify;\">在程序执行的过程中，变量存储的值可以随时改变，而常量存储的值是不可以改变的。</p><p style=\"text-align: justify;\">变量用于存储临时数据信息。某一变量被定义的时候，系统会自动为该变量分配一个存储空间存放变量的值。我们可以在定义变量的时候对其赋值，如果需要改动变量的值，只需再次对其</p><p style=\"text-align: justify;\">进行赋值即可。对于那些临时数据信息或者处理过程，都可以存放在变量中。</p><p style=\"text-align: justify;\">常量用于存储不经常改变的数据信息。定义常量的时候可以对其赋值，在程序的整个执行期间内，这个赋值都有效且不可再次对该常量进行赋值操作。</p><p style=\"text-align: justify;\">我们先从php常量与变量的定义来看两者有什么不同：</p><p style=\"text-align: justify;\">常量：在PHP我们使用define()函数来定义常量 详见：<a href=\"http://www.php.cn/php-weizijiaocheng-360910.html\" target=\"_blank\">PHP常量的定义与使用实例详解</a></p><p style=\"text-align: justify;\">变量：PHP中的所有变量都是用$开头，然后后面跟上变量的名称，在给变量赋值。 详见：<a href=\"http://www.php.cn/php-weizijiaocheng-360960.html\" target=\"_blank\">PHP变量的定义与使用实例详解</a></p><p style=\"text-align: justify;\">从php常量与变量定义来看我们可以得到：</p><ol><li><p style=\"text-align: justify;\">常量前面没有美元符号（$）；<br></p></li><li><p style=\"text-align: justify;\">常量只能用 define() 函数定义，而不能通过赋值语句；</p></li></ol><p style=\"text-align: justify;\">再看一下php常量与变量被定义后有什么不同：</p><p style=\"text-align: justify;\">常量：常量被一旦定义就不能被重新定义或者取消定义。</p><p style=\"text-align: justify;\">变量：变量指的就是在程序执行过程中数值可以变化的量，它与我们所讲的常量是相反的</p><p style=\"text-align: justify;\">这样我们又能得到一下的结果：</p><p style=\"text-align: justify;\">常量只要被定义就不能改变，而变量是可以改变的。</p><p style=\"text-align: justify;\">再看一下常量与变量的值：</p><p style=\"text-align: justify;\">常量：常量的值只能是标量,即可以是 整型 浮点型 布尔型 null 字符串等，不能是 数组 对象 资源，而变量可以是PHP所有的数据类型（<a href=\"http://www.php.cn/php-weizijiaocheng-360575.html\" target=\"_blank\">PHP的八种数据类型</a>）。</p><p style=\"text-align: justify;\">在看一下php常量与变量的作用域：</p><p style=\"text-align: justify;\">常量的作用域：常量无论在那定义，都可以直接调用，没有作用域。</p><p style=\"text-align: justify;\">变量的作用域：变量定义在那个范围就在那个范围有效，如函数中定义的变量就只在函数中有效。</p><p style=\"text-align: justify;\">总结：</p><p style=\"text-align: justify;\">通过上面的内容我们可以总结一下几点来上面php常量与变量的区别：</p><p style=\"text-align: justify;\">1. 常量前面没有美元符号（$）<br>2. 常量只能用 define() 函数定义，而不能通过赋值语句<br>3. 常量可以不用理会变量范围的规则而在任何地方定义和访问<br>4. 常量一旦定义就不能被重新定义或者取消定义<br>5. 常量的值只能是标量</p>', '2018-06-20 22:51:02', '常量与变量的区别', '3');
INSERT INTO `article` VALUES ('35', '<blockquote><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">这个年代，不怕你是大牛，就怕大牛还会写文章。<br></span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">作为AI100智库专家，智亮总是能在口若悬河中，让人深入浅出地学到一堆堆干货，掏心窝子的干货。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">多年的实战经验，让智亮无论是在知乎解答，还是各路博客上，都是大神一样的存在。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">就在前几日，跟智亮聊起来AI入门这个话题，他的滔滔江水延绵不绝实在是震惊了我，太实用了。再三要求下，智亮答应将其多年心得写出来，这一写就洋洋洒洒近万字，无论是他对未来豪情万丈般的预判，还是对于实战细致入微的解析，还是一番苦口婆心的劝导，全在里面不吐不快了。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">这篇文章主要解决三个问题：</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">1.开发人员是否应该转向机器学习？</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">2.需要什么条件才能转向机器学习？</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">3.应该怎么开始机器学习？</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">末了，智亮说，写完有一种身体被掏空的感觉。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">看来是真下了功夫啊！</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"font-size: 15px; color: rgb(136, 136, 136);\">以下，enjoy。</span></p></blockquote><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><span style=\"font-size: 14px;\">作者 |&nbsp;智亮</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><span style=\"font-size: 14px;\">编辑 | 鸽子</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\"><span style=\"font-size: 20px;\">曾</span></span><span style=\"color: rgb(63, 63, 63);\">几何时，我们读着比尔盖茨的传记，感叹他大学时就能徒手写OS的天才同时，也不禁唏嘘：现在写一个OS又哪是几个人几台电脑能搞的定的。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">乔布斯的车库创业，虽然听着比鸡汤还暖心，可是那个时代毕竟已经过去了。留下的，只有无数挣扎着从C++/Delphi转型的资深程序员。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">互联网崛起的时代，马化腾带着几个人就开发出了OICQ，造就了如今偌大的腾讯帝国。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">智能手机爆发的时代，随便山寨一个游戏就能赚得盆满钵满；而现在，即使用心做了一个APP，推广费用至少也是百万级吧。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">互联网（以及移动互联网）时代，已经接近尾声，草根创业变得无比艰难。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">代表着互联网时代的JAVA程序员们，开始日落西山；而代表着移动互联网时代的Android/iOS程序员们，应该也感受到就业形势的日趋严峻吧。<br></span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">每一波浪潮的到来，都意味一片无人占领的蓝海，也意味着众多新成长起来的巨头，还意味着什么？意味着大量的人员需求，供不应求的开发市场，以及从业者的高薪与众多的机会。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">我们最常做的事情是目送着上一次浪潮的余波远去，感叹自己生不逢时，却没有意识到，下一波浪潮已经到了我们脚下。</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">百度前首席科学家吴恩达曾经说过，在他看来，机器学习对于世界的改变，可以与电能对于世界的改变相媲美。而更多的人，已经开始用“第四次工业革命”来预言人工智能带来的产业革新：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">前三次工业革命，让人类摆脱了重体力劳动、精细体力劳动、简单计算劳动。而这一次，伴随着人工智能而来的机器学习，很可能让人类不必在简单思考判断类劳动上消耗大量人力资源。</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">比如，目前仅在中国就有出租车130万辆，载货车辆超过千万，也就是说，每天以“驾驶”作为主要职业的人群就达到千万量级。如果自动驾驶得以普及，至少在中国就有千万人被“释放”，也就是说，老司机们得重新学一门吃饭的手艺了。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">再比如安防领域，全国每天坐在各种监控屏幕前的人（没错，就是每部谍战/犯罪类电影里都会被抹脖子的那个职业）也接近百万。可是，当智能摄像头出现时，监控人员将败给在0.1秒内就会判断反常局面、识别数万人脸的AI;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">还有视频网站鉴黄师，将输给没有荷尔蒙却能每秒检出数百段色情视频的AI；</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">同声传译员会败给没有延迟、并且可以同时用几十种不同语言跟人聊天的AI;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">还有网文筛选编辑、快递地址分拣员等等，这些我们听说过或者没有听说过的职业，这些消耗着无数人的时间和精力的职业，都将一一被AI打败。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">这不是简单的失业和再就业的问题，而是一次全新的社会结构大调整，一次对我们习以为常的生活伤筋动骨的革新。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">就在机器学习砸掉这些人饭碗、逼迫他们投入到其他的工作时，我们的社会，已经开启了新一轮的历史性革新。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">让我们细细来个例子。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">自动驾驶，这是巨头公司投入了大量精力的领域。很多人直观的感受是，以后买辆车，开起来可就不用那么累了。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">的确如此，但并非这么简单。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">让我们深入这个问题。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><br></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">如果所有车辆都变成了自动驾驶，你真的还需要买一辆车吗？</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">我们购买车辆的时候，买的不是四个轮子加一个发动机，而是购买“随时随心快速出行的能力”，使我们不必忍受公交太挤、有急事打不到车、偏远地区去了回不来等等困扰。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">而在自动驾驶的情况下，司机交班、扎堆、偏远地方打不到车，网上叫车没人接单等情况，还会存在吗？如此，我们又何必每个人买一辆车，忍受路上堵、停车难这些困扰呢？</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">到时候，大量的无人车在各种巨型停车场静静地趴着，只要有人下单，几分钟后，就会有一辆无人车来到你面前，任你驱使。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">让我们再沿着这个思路想深一些。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">当无人车充斥我们周围时，这些车辆是否一定有必要设计成五座？也许根据实际运营数据的分析，单人车辆、二人车辆会成为无人车辆的主流，不仅出行更加便捷，减少浪费，还能大大减轻交通流量压力，缓解拥堵。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">未来，很有可能连交通拥堵也没有了。设想，当所有车辆的实时状况，都通过网络汇总到管控机构，管控机构便能根据实时路况，与车辆遥相呼应，车辆自动规划更为合适的路径，自动缓解交通压力。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">不妨再想想，当智能驾驶足够可靠的时候，现在的交通路口红绿灯机制是否还有必要？甚至说，现在的一切交通规则是否会有一个巨大的改变？</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">这还仅仅是针对一项技术开出的脑洞，就已经足够改变现有的整个出行结构和出行规则。未来人工智能的每一项技术，都是对所在行业的彻底改写。至于能改写成什么，恐怕没有人能说得清楚。</span></p><p style=\"text-align: justify;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">唯一可以想象的是，我们在不需要学习外语，不需要考驾照的同时，会需要更多的机器学习专家和相关开发人员。</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">其实，上面这些事情，身在IT圈中的人，应该都有着直观的认识。最近这两年，谈论机器学习，神经网络的人越来越多，而各种“人工智能”相关的消息也是铺天盖地，大有“不入圈就淘汰”的汹汹势头。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">但与此同时，各种不明觉厉的言词也吓退了很多非科班出身的开发者。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">什么叫卷积神经网络？什么叫凸优化？是不是还要回去重读高数，线代，概率？那么一大堆公式，感觉完全看不懂啊？听说没个名校博士出身都搞不了这个？</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">不光是普通程序猿这么说，文艺的程序猿和……额，高大上的程序猿也都这么说。</span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">我说，呵呵。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">在很久以前的一篇知乎回答中提过，作为开发人员，机器学习界在我看来会分成这么几个层次：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><span style=\"color: rgb(70, 118, 217);\">➤&nbsp;</span>1. 学术研究者</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><br></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">他们的工作是从理论上诠释机器学习的各个方面，试图找出“这样设计模型/参数为什么效果更好”，并且为其他从业者提供更优秀的模型，甚至将理论研究向前推进一步。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">能够做到这一步的人，可以说凤毛麟角，天赋是绕不过去的大山，机遇和努力也缺一不可。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><span style=\"color: rgb(70, 118, 217);\">➤&nbsp;</span>2. 算法改进者</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">他们也许无法回答出“我的方法为什么work”，也许没有Hinton，LeCun那样足以载入史册的重大成果，但是却能根据经验和一些奇思妙想，将现有的模型玩出更好的效果，或者提出一些改进的模型。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">这些人通常都是各个机器学习巨头公司的中坚力量或者成长中的独角兽，使用什么模型对他们来讲也不是问题，根据所处的环境，通常都有固定的几个选择。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">在这个层面，insight和idea才是重要的东西，各种工具的区别，影响真的没那么大。</span><span style=\"color: rgb(63, 63, 63);\">可能会让一个结果早得到或者晚得到几天或者几周，却不可能影响“有没有成果”。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><span style=\"color: rgb(70, 118, 217);\">➤</span>&nbsp;3. 工业实现者</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">这些人基本上不会在算法领域涉入太深，也就是了解一下各个算法的实现，各个模型的结构。他们更多地是根据论文去复现优秀的成果，或者使用其他人复现出来的成果，并且试图去在工业上应用它。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">分好了类，来说正事。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">想要成为一个机器学习开发人员，究竟需要做些什么准备？到底如何才能从一个C++/JAVA/Android/iOS程序猿成为一个机器学习开发人员呢？</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">答案只有一个：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\">Just Do IT（去搞IT吧，少年）</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(63, 63, 63);\"><br></span></p><p style=\"text-align: center;\"><br></p><p style=\"text-align: justify;\"><span style=\"color: rgb(123, 12, 0);\">作为程序员，读十遍书不如跑一遍程序</span><span style=\"color: rgb(63, 63, 63);\">，与其花费大量的时间去啃书本，不如亲手完成自己的程序并运行它。我们在写出代码的同时，就会了解到自己还有哪些地方不够清楚，从而有针对性地学习机器学习。</span></p>', '2018-06-20 22:52:43', '成功转型机器学习,多年的经验分享', '6');
INSERT INTO `article` VALUES ('36', '<p><span style=\"color: rgb(51, 51, 51);\"><span style=\"font-size: 14px; color: rgb(136, 136, 136);\"><span style=\"color: rgb(49, 133, 155);\">在各个年龄段的程序猿中，70后以年龄优势遥遥领先，80后开始油腻，90后开始掉发，掉发的迅猛程度隐隐有赶超80后的趋势，脱单已然不是他们最担心的问题，脱发才是!</span></span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">程序猿敲掉不不光是键盘上的字母，更是头顶上原本可怜兮兮的头发……曾经小鲜肉如今变成了“地中海大叔”。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">双十一过后，苏宁IT基于内部500名程序员的头发分析，正式对外发布了“脱发”大数据。更是为6000+程序猿享受了一场特殊的保健服务——发保健。</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1Ge4HqGhG2GQKr2021OvRibuXfgiceicPpWQwE5p8GD6b3sMyL6BUicQe8RQ/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1\"></p><p style=\"text-align: justify;\"><span style=\"font-size: 14px; color: rgb(165, 165, 165);\">苏宁公布程序员脱发数据</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">在苏宁IT体系内，程序猿的“种类”繁多，他们分布在各个研发中心内。据了解，不同岗位的程序猿有着不一样的脱发数值变量。但一样的是，现在跟一个程序猿说“你最近头发掉的有点多”，要比跟他说“你最近发福了”还要过分!因为肥可以减，发际线可是一去不复返的。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">代码和BUG是程序员的日常，数量的多少也直接或间接地影响着程序猿的发量 !鲁迅先生有言在先：头顶本没有路，写的代码多了，也就成了路。每一根掉落的头发上，都赫然印有两个字——Hello,World!数据显示，日行代码100行和1000行相比，头顶的那片草原明显不一样。</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/xRcRSdibCoClINpUro3geO0j77GRicnFh7afLwDhuEw30rawPuuiaicc6WutAUOkUYTqc21coh3UKrUdtFnjO3DyGQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">Bug对于程序猿来说，乃臭虫也!人人恨之!但无系统不Bug!查找、调试并修复一个Bug，短则1日，长则数月!每改一个BUG，对程序猿的头发来说都是一次洗礼，风吹雨淋日渐稀少。当然，对于任何程序猿来说，找到一个Bug是要比找到一个白富美要简单的多!</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155);\">网络上流传这么一个段子：</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">记者问一个大爷：大爷，您保持亮丽的秘诀是什么?</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">大爷说：白天敲代码，晚上撸系统，姿势不要动，眼动手动就可以。</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">记者：啊?大爷您是做什么工作的?</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">大爷：敲代码的呀。</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">记者：那大爷您是本身就很喜欢光头的吗?</span></p><p><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">大爷：掉光的~</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GL7z53njblnj4QibOiaNgecpzKAGFfpzc87mbcVtrViaziaWVrOiaNzICI5g/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">先也不说别的，看看中关村地铁站俯视图吧，懂的点赞。</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GuFql5MickpPCOcQw55QkWN9cecr7AOtIv9Vh9zN3TV8lp9yr989fmYA/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"font-size: 12px; color: rgb(165, 165, 165);\">中关村地铁站秃顶程序员</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">不光是你身边的程序猿发际线日渐高升，我们来看看世界顶尖程序语言开发者吧!</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">1</span><span style=\"font-size: 16px;\">Java之父 James Gosling</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">我们首先来看Java语言，这几年大数据、Android、微服务的大行其道而如日中天(三个领域均在开发中均会使用大量Java代码)。这在1998年Java刚出道时，很多人是完全预料不到的。但如果我们看看Java之父James Gosling的头顶茂密指数，便一目了然。(小编猜想，可能边敲代码，边喝咖啡的缘故吧)</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GDtPNWqPW6icrnLNKAwiaM07VOcucoML5qjUibqfS6DgN3O7BMVibcPSDmg/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：1</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">2</span><span style=\"font-size: 16px;\">Objective-C 之父 Brad Cox</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">Objective-C诞生于上世纪80年代。起初波澜不惊，但随着乔布斯的东山再起，为Mac和iOS立下汗马功劳。但如今，也开始走下坡路。Why? 先来看看Objective-C他爹Brad Cox的头顶。还算不错，金发碧眼!可为啥两侧长中间短呢?</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GKsHj6085zdK6I5APNZkP8cxrics0pOmicCV7ZwJ4nYibH1qCoghiaSHJ5A/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：5</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">3</span><span style=\"font-size: 20px;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">Swift之父 Chris Lattner</span></span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">再来对比看看当红炸子鸡，号称Objective-C killer-up的Swift语言。简直就是程序猿世界中的一股清流啊，“猫耳朵”头顶还是帅出了新高度。长得帅还比你努力的人都是这样!欲哭无泪。。。</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GjFibicIKuiaDlEfBoj30nObbyFbHriaGB7QP6iamcS6v1A2ib6Hp2Doic0vFQ/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：3</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">4</span><span style=\"font-size: 16px;\">GO语言之父 Rob Pike</span></p><p style=\"text-align: justify;\">看看人家Go语言，人家不只是含着Google的金钥匙出生，人家后天也很努力啊。牛逼是有资本的，来看看Go语言爸爸Rob Pike吧。就凭这锃光瓦亮的头顶，老九君断言：服务器端Go来主宰天下，指日可待。</p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GnW695EyzAbM5yTjqAXnkzLukxFh3RkoGgmR2vAlkcJTFc3Jmsv07aQ/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：0.5</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">5</span><span style=\"font-size: 16px;\">C语言之父 Dennis Ritchie</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">很多同学现在都还喜欢问“要不要学C语言，学C语言有什么用?老九君就不想再强调理解Computer System的本源在C语言了，只想说，看看Dennis Ritchie的发迹线就知道答案了。</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GhAXONavlOmcekVJ9VhA19ibJs8OMxlqibyTvAgmdEFJNLRctocmzwLpg/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：3</span></p><p><span style=\"color: rgb(198, 198, 199); font-size: 50px;\">6</span><span style=\"font-size: 20px;\">C++之父 Bjarne Stroustrup</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">好了，最后一个说说C++。虽然当初是听从了C++之父Bjarne Stroustrup“为了提高程序员的工资，因此创立了C++”这一江湖传言。“&nbsp;在学习C++的过程中，被各种模板、各种内存泄漏、各种指针的指针的指针的指针折磨......也许，能让无数小白数十年如一日地坚持到现在，最大的精神动力也许就是教主Bjarne Stroustrup那锃光瓦亮的光明顶了!</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1GQFCERsK9158cwd2yYNPWbmtPDAf5AIZpO7Eibciapv4yG4ia8IJsaiap7g/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">头顶茂密指数：1</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">如此看来，这些程序语言开发先驱们在开发了高级语言的同事，也开垦着程序猿们的头顶啊！那么，是因为大量的开发工作导致用脑过度而脱发得吗??那这可得算工伤啊!</span></p><p><span style=\"font-size: 14px;\">程序员秃顶算工伤吗?</span></p><p style=\"text-align: justify;\"><img src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/xP7JY2OM4TQTLpfib1MibtH5KAzeOO8JrrmPsxqsTx71tP8lKolA3LJHMm1DfTPOib3d21qjE2uELntHJZ5zIa71A/640?wx_fmt=gif\" alt=\"640?wx_fmt=gif\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">很遗憾，程序员秃头不算工伤!不算工伤!!不算工伤!!!</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">程序员秃头并非国家规定的职业病，并非因为工作原因遭受事故伤害造成的，不符合工伤认定条件，不能认定为工伤。</span></p><p style=\"text-align: justify;\"><img width=\"333\" src=\"http://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_jpg/IEccNBf01KjnlMtcd733TZHicw8DY1ic1G1S0GXGnyxX9icSQHuLibo6JCwRRiaju1D6ibATTTbYRQNf2iaibgwKEicaTnA/640?wx_fmt=jpeg\" alt=\"640?wx_fmt=jpeg\"></p><p style=\"text-align: justify;\"><span style=\"color: rgb(165, 165, 165); font-size: 12px;\">工伤保险条例</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155);\">《工伤保险条例》是这么规定的：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">第十四条　职工有下列情形之一的，应当认定为工伤：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(一)在工作时间和工作场所内，因工作原因受到事故伤害的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(二)工作时间前后在工作场所内，从事与工作有关的预备性或者收尾性工作受到事故伤害的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(三)在工作时间和工作场所内，因履行工作职责受到暴力等意外伤害的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(四)患职业病的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(五)因工外出期间，由于工作原因受到伤害或者发生事故下落不明的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(六)在上下班途中，受到非本人主要责任的交通事故或者城市轨道交通、客运轮渡、火车事故伤害的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(七)法律、行政法规规定应当认定为工伤的其他情形。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">第十五条　职工有下列情形之一的，视同工伤：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(一)在工作时间和工作岗位，突发疾病死亡或者在48小时之内经抢救无效死亡的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(二)在抢险救灾等维护国家利益、公共利益活动中受到伤害的;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">(三)职工原在军队服役，因战、因公负伤致残，已取得革命伤残军人证，到用人单位后旧伤复发的。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">职工有前款第(一)项、第(二)项情形的，按照本条例的有关规定享受工伤保险待遇;职工有前款第(三)项情形的，按照本条例的有关规定享受除一次性伤残补助金以外的工伤保险待。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155);\">程序员为什么会秃顶？</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">导致脱发秃顶的原因有很多，但是根据每个人的身体因素来说秃顶的原因都不大一致，但是最常见的六大秃顶原因是：</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">病理性秃顶;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">肥胖性秃顶;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">物理性秃顶;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">营养性秃顶;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">脂溢性秃顶;</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">化学性秃顶。</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155); font-size: 14px;\">程序员如何预防秃顶</span></p><p style=\"text-align: justify;\"><span style=\"color: rgb(49, 133, 155);\">既然不算工伤，那我预防可以预防吗?</span></p><p><span style=\"color: rgb(49, 133, 155);\">&nbsp; 1.</span><span style=\"color: rgb(49, 133, 155);\">多吃一些含铁、钙、锌等矿物质和维生素A、B、C以及含蛋白质较多的食品，如含有丰富蛋白质的鱼类、大豆、鸡蛋、瘦肉等以及含有丰富微量元素的海藻类、贝类富含维生素B2、B6的菠菜、芦笋、香蕉、猪肝等都对保护头发、延缓老化有好处，保持大便通畅则有利于头发的正常生长，预防脱发。　　 　　</span></p><p><span style=\"color: rgb(49, 133, 155);\">2.避免对头发的伤害：吸烟会使头皮毛细管收缩，从而影响头发的发育生长。热白酒会使头皮产生湿气，引起脱发。 　　烫发吹风要慎重：吹风机吹出的温度高会破坏毛发组织，损伤头皮，因此要避免吹热风。烫发液对头发的影响较大，要减少烫发次数。 　　</span></p><p><span style=\"color: rgb(49, 133, 155);\">3.保持头发的清洁：选用对头皮和头发无刺激性的洗发剂，洗头时可在水中滴几滴醋或放少许盐，洗头的水不宜太热或太冷洗头的间隔最好是每天一次，洗发的同时需边搓边按摩。 　　</span></p><p><span style=\"color: rgb(49, 133, 155);\">4.选择专业健发：可能很多人开始注意到就算自己很细心的呵护头发，还是会发生脱发现在。这时应该意识到脱发的严重性，及早选择寻求专业人士帮助，是正确的解决之道。 　　</span></p><p><span style=\"color: rgb(49, 133, 155);\">5.按摩头皮：每日睡觉前和次日起床后，将双手十指插入发内，从前额经头顶到后脑揉搓头皮，每次2分钟至4分钟。&nbsp;</span></p>', '2018-06-20 22:53:52', '程序猿秃顶算工伤吗？', '6');
INSERT INTO `article` VALUES ('39', '<p>学习前端HTML，CSS首先必须遵循基本的视频。那么我们需要做很多练习，案例和案例都很重要，应用到现实中，要做各种常规的、陌生的、大量的练习题来巩固和理解自己的知识。</p><p>要学习JavaScript，你首先需要知道语言能做什么，你不能做什么，你擅长什么，你不擅长什么。</p><p>如果你只是想成为一个普通的前端程序员，你只需要记住大部分的JavaScript函数并做一些练习。</p><p>JavaScript是前端开发人员的核心，也是工资标准。现在有一些特别的JavaScript工程师，他们的薪水很高。</p><p>如果您想了解JavaScript，您需要了解JavaScript的原理和机制。我们需要知道它们的起源，我们需要了解基于对象的JavaScript的本质。</p><p>我们还需要深入了解浏览器主机下JavaScript的行为和特性。</p><p>优秀的或优秀的前端开发人员有什么条件？</p><p>过去，一个小的操作可以使PS图像处理软件和Dreamweaver网页，即Web1.0的时代。当我们没有前端时，它被称为网页制作。</p><p>现在还不足以掌握这一点。无论是开发的困难还是发展的方式，Web生产都离传统网站的发展更近了。所以现在它不再被称为Web产品，而是Web前端开发。</p><p>随着Internet的飞速发展，HTML5技术的不断成熟和大型浏览器的不断兼容，前端的开发非常普及，使得Web前端的开发成为最热门的职业。</p><p>1。前端是什么？</p><p>总结这两个词，界面。包括网页、Windows、手机、微信等，只要用户能看到东西，就可以是前端。</p><p>当然，你可以看到你想做什么。</p><p>事实上，你可以看到房子的前面是HTML，它是房屋结构和房屋地基的一部分。CSS，就像我们房子的装饰，墙壁的颜色，风格和地板。这个CSSJavaScript改变了房子的风格，就像房子的功能一样。这房子需要冷藏，需要供暖。它还需要进入水中。这些函数是等价的，所以JavaScript的例子可能不合适，只是为了帮助大家有初步的了解。</p><p>2。软件开发</p><p>作为一个优秀的前端工程师，当然，任何软件都可以很容易地控制（这里我们可以开发前端软件）。当然，它也将忠实于一个开发软件到两个软件。作为一个没有进入的工程师，它可以选择较旧的卡，也就是说，完整的函数总是正确的。Dreamweaver和记事本都是正确的。如果你买一本书，这是对数据的一个很好的介绍。</p><p>三。代码理解</p><p>前端开发概述及代码介绍</p><p>作为前端工程师，页面基本结构、文档声明、编码声明、CSS语法、样式属性、链接和样式标签、ID属性、基本样式、边框、背景、字体、框架模型、文本集等。常用的标签、标题、文章、部分页脚导航，H1-H6，P，UL，OL，李，IMG，P，和其他绝对路径，相对路径，标签语义嵌套规范，搜索引擎优化…等等，这些或多或少都是你想掌握的，其中一些可能不被使用，但是理解也是对多程序的更深理解。</p><p>公共选择器和标签类型分区</p><p>D、类、类型选择，包括选择、组选择、通配符、选择器优先级、标签样式初始化、自定义、超链接和伪类分区、标签类型分类和特征、内联、内联、块等。</p><p>前浮动</p><p>特性、浮动、浮动、文件流、流量问题、BFC（块级格式化上下文）、触发条件，定义了HasFaySand和HasFrand触发器。</p><p>位置</p><p>相对定位、绝对定位、绝对定位、固定定位、遗传继承、静态定位、缺省值、水平问题、负利润和透明度。</p><p>形式与形式</p><p>表标签、表格样式重置、单元格合并、表单元素、表单相关属性操作和窗体默认样式初始值。</p><p>4、高级编码</p><p>理解原来的编码，但做一个工程师是不够的。它需要更深的理解。</p><p>兼容性问题的处理</p><p>兼容性问题，萧边说，是一个坑的前端。大多数浏览器现在都是人性化的，但有些用户没有升级或类似IE6或7浏览器。总结了兼容性问题。指出了浮动IE6、7、低版本IE浏览器、低版本IE浏览器的新标签、CSHACK、条件注释、PNG透明支持和IE低版本的固定位置的形式问题。</p><p>这不是一个大项目。IE浏览器放弃了。</p><p>先进站</p><p>样式设计、图标、CSS精灵、URI数据、隐藏元素、使用测试工具、滑动门、布局、三列布局在容器中是未知的宽度和高度的图像、水平和垂直的中位数、垂直和水平文本、多行文本在垂直和水平上。</p><p>CSS3介绍</p><p>转换，属性选择器，N类型，N个子，背景大小，框大小，圆角，框模型阴影，文本阴影，RGBA，表单进阶，H5形成新属性，E：非（S）E：目标：E:</p><p>移动终端布局</p><p>在模拟测试环境下，对窗口的物理分辨率、DeVeleXeleRe比率、视图、查询、媒体、REM、窗口、屏幕、窗口、Debug定位等事件相关问题、移动终端的屏幕布局、判断…</p><p>动画与变换</p><p>前缀，执行命令帧动画，浏览器调用，设置动画的数量，甚至调用顺序，动画，无缝滚动动画，暂停，旋转，歪斜，缩放，缩放位移，变换原点，变换…</p><p>领导前端开发框架（或其他框架）</p><p>HTML语法规范，CSS语法规范，嵌套在越来越复杂，类命名，选择器，Normalize.css，网格系统，排版，代码，响应工具。</p><p>5、项目实战</p><p>当你知道以上所有问题，或者你能学到更多，恭喜你，你已经开始了。下一步是测试你的学习。</p><p>这里还是要推荐下小编的web前端学习群:606加721加798，不管你是小白还是大牛，小编我都欢迎，不定期分享干货，包括小编自己整理的一份2最新的web前端资料和0基础入门教程，欢迎初学和进阶中的小伙伴。在不忙的时间我会给大家解惑。</p>', '2018-06-21 11:13:29', '123，都进来看看吧', '1');
INSERT INTO `article` VALUES ('40', '<p>暗示的方式的方式</p>', '2018-06-21 11:13:48', '爱上对方撒旦法', '6');

-- ----------------------------
-- Table structure for `blog_user`
-- ----------------------------
DROP TABLE IF EXISTS `blog_user`;
CREATE TABLE `blog_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(255) DEFAULT NULL,
  `pwd` varchar(255) DEFAULT NULL,
  `uname` varchar(255) DEFAULT NULL,
  `admin` bit(1) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_user
-- ----------------------------
INSERT INTO `blog_user` VALUES ('1', 'admin@qq.com', 'admin', '管理员', '');
INSERT INTO `blog_user` VALUES ('2', 'user@qq.com', 'user', '普通用户', '');
INSERT INTO `blog_user` VALUES ('8', '11@qq.com', '1', '1', '');
INSERT INTO `blog_user` VALUES ('9', '2@163.com', '2', 'test', '');
INSERT INTO `blog_user` VALUES ('10', '123@qq.com', '123', '123', '');

-- ----------------------------
-- Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', 'Java');
INSERT INTO `category` VALUES ('2', 'C/C++');
INSERT INTO `category` VALUES ('3', 'PHP');
INSERT INTO `category` VALUES ('4', 'HTML');
INSERT INTO `category` VALUES ('5', 'Python');
INSERT INTO `category` VALUES ('6', '推荐文章');

-- ----------------------------
-- Table structure for `comment`
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `flag` int(11) DEFAULT NULL,
  `article_id` int(11) DEFAULT NULL,
  `auser_id` int(11) DEFAULT NULL,
  `quser_id` int(11) DEFAULT NULL,
  `report` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FK5yx0uphgjc6ik6hb82kkw501y` (`article_id`),
  KEY `FKjkjgd5bi1e8mh1uk8dw1qli5w` (`auser_id`),
  KEY `FK3t2r5r5rloa8gd6eo8hj0hot5` (`quser_id`),
  CONSTRAINT `FK3t2r5r5rloa8gd6eo8hj0hot5` FOREIGN KEY (`quser_id`) REFERENCES `blog_user` (`id`),
  CONSTRAINT `FK5yx0uphgjc6ik6hb82kkw501y` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`),
  CONSTRAINT `FKjkjgd5bi1e8mh1uk8dw1qli5w` FOREIGN KEY (`auser_id`) REFERENCES `blog_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '这篇文章写的非常好', '2018-06-20 23:06:04', '1', '34', null, '2', '');
INSERT INTO `comment` VALUES ('2', '谢谢', '2018-06-20 23:19:28', '1', '34', '1', '2', '');
INSERT INTO `comment` VALUES ('3', 'ASDFS', '2018-06-21 11:12:26', '1', '20', null, '2', '');
INSERT INTO `comment` VALUES ('4', '水电费客家话 ', '2018-06-21 11:14:37', '1', '20', '1', '2', '');

-- ----------------------------
-- Table structure for `links`
-- ----------------------------
DROP TABLE IF EXISTS `links`;
CREATE TABLE `links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of links
-- ----------------------------
INSERT INTO `links` VALUES ('2', 'Github', 'http://github.com');
INSERT INTO `links` VALUES ('7', 'Bootstrap中文网', 'http://www.bootcss.com/');
INSERT INTO `links` VALUES ('8', 'Spring官网', 'https://spring.io/');
INSERT INTO `links` VALUES ('9', 'IntelliJ IDEA', 'https://www.jetbrains.com/idea/');
